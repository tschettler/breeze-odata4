import {
    AutoGeneratedKeyType,
    config,
    DataProperty,
    DataService,
    DataServiceAdapter,
    DataServiceConfig,
    DataType,
    Entity,
    EntityManager,
    EntityQuery,
    JsonResultsAdapter,
    MappingContext,
    MetadataStore,
    NamingConvention,
    SaveBundle,
    SaveOptions,
    SaveResult
} from 'breeze-client';
import { AjaxFetchAdapter } from 'breeze-client/adapter-ajax-fetch';
import { DataServiceWebApiAdapter } from 'breeze-client/adapter-data-service-webapi';
import { ModelLibraryBackingStoreAdapter } from 'breeze-client/adapter-model-library-backing-store';
import * as fs from 'fs';
import * as path from 'path';
import { Batch, HttpOData } from 'ts-odatajs';

import { NavigationAdapter } from '../src/adapters';
import { BreezeOData4 } from '../src/breeze-odata4';
import { DataServiceSaveContext, OData4DataService } from '../src/breeze-odata4-dataService';
import { ClassRegistry } from '../src/class-registry';
import { DataTypeSetup } from '../src/datatypes/setups/datatype-setup';
import { ODataError } from '../src/odata-error';
import { ODataHttpClient } from '../src/odata-http-client';

const metadataXml = fs.readFileSync(
    path.join(__dirname, './metadata.xml'),
    'utf-8'
);
const invalidMetadataXml = fs.readFileSync(
    path.join(__dirname, './invalid-metadata.xml'),
    'utf-8'
);
jest.mock('../src/class-registry');

const DefaultDataService: DataServiceAdapter = config.getAdapterInstance('dataService');

const MockWebApiDataService = jest.fn<DataServiceAdapter, []>(
    () =>
        ({
            name: 'webApi',
            _catchNoConnectionError: jest.fn(),
            _createChangeRequestInterceptor: jest.fn(),
            checkForRecomposition: jest.fn(),
            _prepareSaveBundle: jest.fn(),
            _prepareSaveResult: jest.fn(),
            initialize: jest.fn(),
        } as any)
);

describe('OData4DataService', () => {
    let sut: OData4DataService;
    let innerAdapter: DataServiceAdapter;

    beforeAll(() => {
        ModelLibraryBackingStoreAdapter.register();
        AjaxFetchAdapter.register();
        DataServiceWebApiAdapter.register();
    });

    beforeEach(() => {
        jest.clearAllMocks();
        config.registerAdapter('dataService', MockWebApiDataService);
        OData4DataService.register();
        config.initializeAdapterInstance(
            'dataService',
            OData4DataService.BreezeAdapterName,
            true
        );

        sut = (config.getAdapterInstance('dataService'));
        innerAdapter = ((
            config.getAdapterInstance('dataService', 'webApi')
        ));
    });

    it('should return value for metadataAcceptHeader', () => {
        const result = sut.metadataAcceptHeader;
        expect(result.length).toBeGreaterThan(0);
    });

    it('should have OData-Version 4.0 header', () => {
        const result = sut.headers;
        expect(result['OData-Version']).toEqual('4.0');
    });

    it('should create instance of OData4DataService when constructor is called', () => {
        const svc = new OData4DataService();
        expect(svc).toBeInstanceOf(OData4DataService);
    });

    it('should register DataService when register is called', () => {
        const adapter = config.getAdapterInstance('dataService');
        expect(adapter).toBeInstanceOf(OData4DataService);
    });

    it('should call inner adapter when _catchNoConnectionError is called', () => {
        sut._catchNoConnectionError(new ODataError());

        expect((innerAdapter as any)._catchNoConnectionError)
            .toHaveBeenCalledTimes(1);
    });

    it('should call inner adapter when _createChangeRequestInterceptor is called', () => {
        sut._createChangeRequestInterceptor(null, null);

        expect((innerAdapter as any)._createChangeRequestInterceptor)
            .toHaveBeenCalledTimes(1);
    });

    it('should call inner adapter checkForRecomposition', () => {
        expect(innerAdapter.checkForRecomposition).toHaveBeenCalledTimes(1);
    });

    it('should call inner adapter when _prepareSaveBundle is called', () => {
        sut._prepareSaveBundle(null, null);

        expect(
            (innerAdapter as any)._prepareSaveBundle
        ).toHaveBeenCalledTimes(1);
    });

    it('should call inner adapter when _prepareSaveResult is called', () => {
        sut._prepareSaveResult(null, null);

        expect(
            (innerAdapter as any)._prepareSaveResult
        ).toHaveBeenCalledTimes(1);
    });

    describe('initialize', () => {
        beforeEach(() => {
            jest.clearAllMocks();
            sut.initialize();
        });

        it('should set jsonResultsAdapter', () => {
            expect(sut.jsonResultsAdapter).toBeInstanceOf(JsonResultsAdapter);
        });
    });

    describe('executeQuery', () => {
        let ctx: MappingContext;
        let ds: OData4DataService;
        let httpClient: ODataHttpClient;
        let response: HttpOData.Response;

        beforeEach(() => {
            response = ({
                headers: {
                    'Content-Type': 'application/json',
                },
                body: '{}',
                requestUri: '',
                statusCode: '200',
                statusText: 'OK',
            } as HttpOData.Response);

            httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            const serviceName = 'http://localhost';
            delete global['window'];
            global['location'] = ({ origin: serviceName } as any);

            const opts: DataServiceConfig = {
                serviceName,
            };

            ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;
            const dataService = new DataService(opts);

            ctx = ({
                dataService,
                getUrl: () => '',
            } as MappingContext);
        });

        it('should throw error for OData Error', async () => {
            httpClient.request = (req, success, error) => {
                error({} as HttpOData.Error);
                return {} as HttpOData.RequestWithAbort;
            };

            await expect(
                ds.executeQuery(ctx)
            ).rejects.toThrowError(expect.any(ODataError));
        });

        it('should return promise', () => {
            const result = ds.executeQuery(ctx).catch(() => { });

            expect(result).toBeInstanceOf(Promise);
        });

        it('should not return null', async () => {
            const result = await ds.executeQuery(ctx);

            expect(result).not.toBeNull();
        });

        it('should map parameters to querystring', async () => {
            const query = new EntityQuery();
            query.parameters = {
                id: 123,
            };
            ctx.query = query;

            let result: string;
            httpClient.request = (req, success, error) => {
                result = req.requestUri;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.executeQuery(ctx);

            expect(result).toContain('?id=123');
        });

        it('should map parameters to existing querystring', async () => {
            const query = new EntityQuery();
            query.parameters = {
                id: 123,
            };
            ctx.query = query;
            ctx.getUrl = () => '/?foo=bar';
            ctx.dataService.serviceName = '/';

            let result: string;
            httpClient.request = (req, success, error) => {
                result = req.requestUri;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.executeQuery(ctx);

            expect(result).toBe('/?foo=bar&id=123');
        });

        it('should not map empty parameters to querystring', async () => {
            const query = new EntityQuery();
            query.parameters = {};
            ctx.query = query;

            let result: string;
            httpClient.request = (req, success, error) => {
                result = req.requestUri;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.executeQuery(ctx);

            expect(result).not.toContain('?');
        });

        it('should use $method from parameters as request method', async () => {
            const method = 'POST';
            const query = new EntityQuery();
            query.parameters = {
                $method: method,
                id: 123,
            };
            ctx.query = query;

            let result: string;
            httpClient.request = (req, success, error) => {
                result = req.method;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.executeQuery(ctx);

            expect(result).toBe(method);
        });

        it('should remove $method from parameters', async () => {
            const method = 'POST';
            const query = new EntityQuery();
            query.parameters = {
                $method: method,
                id: 123,
            };
            ctx.query = query;

            await ds.executeQuery(ctx);

            expect(query.parameters['$method']).toBeUndefined();
        });

        it('should pass parameters as request data by default', async () => {
            const method = 'POST';
            const query = new EntityQuery();
            query.parameters = {
                $method: method,
                id: 123,
            };
            ctx.query = query;

            let result: object;
            httpClient.request = (req, success, error) => {
                result = req.data;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.executeQuery(ctx);

            expect(result).toEqual({ id: query.parameters['id'] });
        });

        it('should pass $data as request data', async () => {
            const method = 'POST';
            const query = new EntityQuery();
            query.parameters = {
                $method: method,
                $data: { id: 123 },
            };
            ctx.query = query;

            ctx.metadataStore = new MetadataStore();
            ctx.entityManager = new EntityManager('http://localhost');

            let result: object;
            httpClient.request = (req, success, error) => {
                result = req.data;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.executeQuery(ctx);

            expect(result).toEqual(query.parameters['$data']);
        });

        it('should pass $data with invalid names as request data', async () => {
            const method = 'POST';
            const query = new EntityQuery();
            query.parameters = {
                $method: method,
                $data: { ID: 123 },
            };
            ctx.query = query;

            ctx.metadataStore = new MetadataStore();
            ctx.metadataStore.namingConvention = NamingConvention.camelCase;
            ctx.entityManager = new EntityManager('http://localhost');

            let result: object;
            httpClient.request = (req, success, error) => {
                result = req.data;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.executeQuery(ctx);

            expect(result).toEqual(query.parameters['$data']);
        });

        it('should pass empty as request data when $data has invalid entity', async () => {
            const method = 'POST';
            const query = new EntityQuery();
            query.parameters = {
                $method: method,
                $data: {
                    id: 123,
                    // entityAspect is now required to fake an entityType or else breeze will consider it to be a complex type
                    entityAspect: {},
                    entityType: { dataProperties: [] }
                }
            };
            ctx.query = query;

            ctx.metadataStore = new MetadataStore();
            ctx.entityManager = new EntityManager('http://localhost');

            let result: object;
            httpClient.request = (req, success, error) => {
                result = req.data;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.executeQuery(ctx);

            expect(result).toEqual({});
        });

        describe('after metadata retrieved', () => {
            let metadataStore: MetadataStore = null;

            beforeEach(async () => {
                httpClient.request = (req, success, error) => {
                    response = ({
                        headers: {
                            'Content-Type': 'application/xml',
                        },
                        body: metadataXml,
                        requestUri: req.requestUri,
                        statusCode: '200',
                        statusText: 'OK',
                    } as HttpOData.Response);
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                metadataStore = new MetadataStore();
                const dataService = new DataService({
                    serviceName: 'http://localhost',
                    hasServerMetadata: true,
                });

                (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                    new NavigationAdapter(),
                ]);
                (ClassRegistry.DataTypeSetups.get as any) = jest
                    .fn()
                    .mockImplementation(() => [] as DataTypeSetup[]);

                await ds.fetchMetadata(metadataStore, dataService);
            });

            it('should pass data to action request when parameter type is not valid', async () => {
                const method = 'POST';
                const query = new EntityQuery();
                const entityManager = new EntityManager({ metadataStore });

                const data = {
                    Id: '1'
                };
                query.parameters = {
                    $method: method,
                    $data: data
                };
                query.resourceName = 'Revisions/OData4Test.Actions.InvalidAction';
                ctx.query = query;

                ctx.metadataStore = new MetadataStore(); // forces type to not exist
                ctx.entityManager = entityManager;

                let result: object;
                httpClient.request = (req, success, error) => {
                    result = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.executeQuery(ctx);

                expect(result).toEqual(data);
            });

            it('should pass data to action request when structural type does not exist', async () => {
                const method = 'POST';
                const query = new EntityQuery();
                const entityManager = new EntityManager({ metadataStore });

                const data = {
                    Id: '1'
                };
                query.parameters = {
                    $method: method,
                    $data: data
                };
                query.resourceName = 'Revisions/OData4Test.Actions.CreateRevision';
                ctx.query = query;

                ctx.metadataStore = new MetadataStore(); // forces type to not exist
                ctx.entityManager = entityManager;

                let result: object;
                httpClient.request = (req, success, error) => {
                    result = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.executeQuery(ctx);

                expect(result).toEqual(data);
            });

            it('should pass entity to action request', async () => {
                const method = 'POST';
                const query = EntityQuery.from('Revisions/OData4Test.Actions.CreateRevision');
                const entityManager = new EntityManager({ metadataStore });

                const entity = entityManager.createEntity('Revision', { Id: '1' });

                query.parameters = {
                    $method: method,
                    $data: entity
                };

                ctx.query = query;

                ctx.metadataStore = metadataStore;
                ctx.entityManager = entityManager;

                let result: object;
                httpClient.request = (req, success, error) => {
                    result = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.executeQuery(ctx);

                const expected = ctx.entityManager.helper.unwrapInstance(entity, null);
                expect(result).toEqual(expected);
            });

            it('should create entity from data for action request requiring entity', async () => {
                const method = 'POST';
                const query = new EntityQuery();
                const entityManager = new EntityManager({ metadataStore });

                const data = {
                    Id: '1'
                };
                query.parameters = {
                    $method: method,
                    $data: data
                };
                query.resourceName = 'Revisions/OData4Test.Actions.CreateRevision';
                ctx.query = query;

                ctx.metadataStore = metadataStore;
                ctx.entityManager = entityManager;

                let result: object;
                httpClient.request = (req, success, error) => {
                    result = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.executeQuery(ctx);

                expect(result['Id']).toEqual(data.Id);
                expect(result.hasOwnProperty('ArticleId')).toBeTruthy();
                expect(result.hasOwnProperty('Content')).toBeTruthy();
                expect(result.hasOwnProperty('PrevId')).toBeTruthy();
                expect(result.hasOwnProperty('Version')).toBeTruthy();
            });

            it('should create complex type from data for action request requiring complex type', async () => {
                const method = 'POST';
                const query = new EntityQuery();
                const entityManager = new EntityManager({ metadataStore });

                const data = {
                    ArticleId: '1',
                    Rating: 9.9
                };
                query.parameters = {
                    $method: method,
                    $data: data
                };
                query.resourceName = 'Articles(1)/OData4Test.Actions.RateArticle';
                ctx.query = query;

                ctx.metadataStore = metadataStore;
                ctx.entityManager = entityManager;

                let result: object;
                httpClient.request = (req, success, error) => {
                    result = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                // save off data because it gets modified
                const expected = {...data};

                await ds.executeQuery(ctx);

                expect(result).toEqual(expected);
            });

            it('should pass data to action request without entity', async () => {
                const method = 'POST';
                const query = new EntityQuery();
                const entityManager = new EntityManager({ metadataStore });

                const data = {
                    id: '1'
                };
                query.parameters = {
                    $method: method,
                    $data: data
                };
                query.resourceName = 'Revisions(1)/OData4Test.Actions.ApproveRevision';
                ctx.query = query;

                ctx.metadataStore = metadataStore;
                ctx.entityManager = entityManager;

                let result: object;
                httpClient.request = (req, success, error) => {
                    result = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.executeQuery(ctx);

                expect(result).toEqual(data);
            });

            it('should pass data to function request', async () => {
                const method = 'POST';
                const query = new EntityQuery();
                const entityManager = new EntityManager({ metadataStore });

                const data = {
                    id: '1'
                };
                query.parameters = {
                    $method: method,
                    $data: data
                };
                query.resourceName = 'Article(1)/OData4Test.Functions.GetRevisions';
                ctx.query = query;

                ctx.metadataStore = metadataStore;
                ctx.entityManager = entityManager;

                let result: object;
                httpClient.request = (req, success, error) => {
                    result = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.executeQuery(ctx);

                expect(result).toEqual(data);
            });
        });
    });

    describe('getAbsoluteUrl', () => {

        describe('with window', () => {
            beforeAll(() => {
                global['window'] = ({} as any);
                global['location'] = ({ origin: 'http://localhost' } as any);
            });

            it('should return relative url when window exists and url starts with double slash', () => {
                const serviceName = '//TestService';
                const opts: DataServiceConfig = {
                    serviceName,
                };

                const ds = new DataService(opts);
                const url = `${serviceName}/$metadata`;

                const result = sut.getAbsoluteUrl(ds, url);

                expect(result).toEqual(url);
            });

            it('should return correct url when window exists and url starts with http', () => {
                const serviceName = 'http://TestService';
                const opts: DataServiceConfig = {
                    serviceName,
                };

                const ds = new DataService(opts);
                const url = `${serviceName}/$metadata`;

                const result = sut.getAbsoluteUrl(ds, url);

                expect(result).toEqual(url);
            });

            it('should return correct url when window exists and url starts with https', () => {
                const serviceName = 'https://TestService';
                const opts: DataServiceConfig = {
                    serviceName,
                };

                const ds = new DataService(opts);
                const url = `${serviceName}/$metadata`;

                const result = sut.getAbsoluteUrl(ds, url);

                expect(result).toEqual(url);
            });

            it('should return absolute url when window exists and url does not start with double slash', () => {
                const serviceName = 'TestService';
                const opts: DataServiceConfig = {
                    serviceName,
                };

                const location = global['location'];

                const ds = new DataService(opts);
                const url = `${serviceName}/$metadata`;

                const result = sut.getAbsoluteUrl(ds, url);

                expect(result).toEqual(`${location.origin}/${serviceName}/$metadata`);
            });

            it('should return absolute url when window exists and url does not start with double slash', () => {
                const serviceName = '/TestService/';
                const opts: DataServiceConfig = {
                    serviceName,
                };

                const location = global['location'];

                const ds = new DataService(opts);
                const url = `${serviceName}`;

                const result = sut.getAbsoluteUrl(ds, url);

                expect(result).toEqual(`${location.origin}${serviceName}`);
            });

            it('should return absolute url when window exists and url does not contain service name', () => {
                const serviceName = 'TestService';
                const opts: DataServiceConfig = {
                    serviceName,
                };

                global['window'] = ({} as any);
                const location = global['location'];

                const ds = new DataService(opts);
                const url = `$metadata`;

                const result = sut.getAbsoluteUrl(ds, url);

                expect(result).toEqual(`${location.origin}/${serviceName}/${url}`);
            });
        });

        describe('without window', () => {
            beforeAll(() => {
                delete global['window'];
            });

            it('should return valid url when url does not contain service name', () => {
                const serviceName = 'TestService';
                const opts: DataServiceConfig = {
                    serviceName,
                };

                const ds = new DataService(opts);
                const url = '$metadata';

                const result = sut.getAbsoluteUrl(ds, url);

                expect(result).toEqual(`${serviceName}/${url}`);
            });

            it('should return valid url when url contains service name', () => {
                const serviceName = 'TestService';
                const opts: DataServiceConfig = {
                    serviceName,
                };

                const ds = new DataService(opts);
                const url = `${serviceName}/$metadata`;

                const result = sut.getAbsoluteUrl(ds, url);

                expect(result).toEqual(url);
            });
        });
    });

    describe('fetchMetadata', () => {
        it('should get metadata', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: metadataXml,
                    requestUri: req.requestUri,
                    statusCode: '200',
                    statusText: 'OK',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            const result = await ds.fetchMetadata(metadataStore, dataService);
            expect(result).toBeTruthy();
        });

        it('should throw error if there is no metadata response', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: '',
                    requestUri: req.requestUri,
                    statusCode: '200',
                    statusText: 'OK',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await expect(
                ds.fetchMetadata(metadataStore, dataService)
            ).rejects.toThrowError(
                'Metadata query failed for: http://localhost/$metadata; Cannot read propert'
            );
        });

        it('should throw error if there is an invalid metadata response', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: '<t></t>',
                    requestUri: req.requestUri,
                    statusCode: '200',
                    statusText: 'OK',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await expect(
                ds.fetchMetadata(metadataStore, dataService)
            ).rejects.toThrowError(
                'Metadata query failed for: http://localhost/$metadata'
            );
        });

        it('should throw error if there is no dataServices element', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: '<edmx:Edmx xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx" Version="4.0"></edmx:Edmx>',
                    requestUri: req.requestUri,
                    statusCode: '200',
                    statusText: 'OK',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await expect(
                ds.fetchMetadata(metadataStore, dataService)
            ).rejects.toThrowError(
                'Metadata query failed for: http://localhost/$metadata'
            );
        });

        it('should throw error if the metadata is invalid', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: invalidMetadataXml,
                    requestUri: req.requestUri,
                    statusCode: '200',
                    statusText: 'OK',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await expect(
                ds.fetchMetadata(metadataStore, dataService)
            ).rejects.toThrowError(
                'Metadata query failed for http://localhost/$metadata; Unable to process returned metadata:'
            );
        });

        it('should throw error with message if exists', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: '{"error":{"message":"Invalid test request"}}',
                    requestUri: req.requestUri,
                    statusCode: '400',
                    statusText: 'BadRequest',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await expect(
                ds.fetchMetadata(metadataStore, dataService)
            ).rejects.toThrowError(
                'Metadata query failed for: http://localhost/$metadata; Invalid test request'
            );
        });

        it('should throw error with message value if exists', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: '{"message":{"value":"Invalid test request"}}',
                    requestUri: req.requestUri,
                    statusCode: '400',
                    statusText: 'BadRequest',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await expect(
                ds.fetchMetadata(metadataStore, dataService)
            ).rejects.toThrowError(
                'Metadata query failed for: http://localhost/$metadata; Invalid test request'
            );
        });

        it('should throw error with empty body', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: '{}',
                    requestUri: req.requestUri,
                    statusCode: '400',
                    statusText: 'BadRequest',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await expect(
                ds.fetchMetadata(metadataStore, dataService)
            ).rejects.toThrowError(
                'Metadata query failed for: http://localhost/$metadata;'
            );
        });

        it('should throw error with odata.error if exists', async () => {
            const httpClient = new ODataHttpClient();
            httpClient.request = (req, success, error) => {
                const response = {
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: '{"odata.error":{"error":{"message":"Invalid test request"}}}',
                    requestUri: req.requestUri,
                    statusCode: '400',
                    statusText: 'BadRequest',
                } as HttpOData.Response;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            delete global['window'];
            global['location'] = ({ origin: 'http://localhost' } as any);
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);
            BreezeOData4.configure();
            const ds = new OData4DataService();
            ds.initialize();
            ds.httpClient = httpClient;

            const metadataStore = new MetadataStore();
            const dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await expect(
                ds.fetchMetadata(metadataStore, dataService)
            ).rejects.toThrowError(
                'Metadata query failed for: http://localhost/$metadata; Invalid test request'
            );
        });
    });

    describe('saveChanges', () => {
        let ds: OData4DataService;
        let metadataStore: MetadataStore;
        let dataService: DataService;
        let httpClient: ODataHttpClient;
        let response: HttpOData.Response;
        let batchResponse: Batch.BatchResponse;

        let entityManager: EntityManager;
        let saveContext: DataServiceSaveContext;
        let saveBundle: SaveBundle;

        beforeAll(async () => {
            (ClassRegistry.MetadataAdapters.get as any).mockReturnValue([
                new NavigationAdapter(),
            ]);
            (ClassRegistry.DataTypeSetups.get as any) = jest
                .fn()
                .mockImplementation(() => [] as DataTypeSetup[]);

            (innerAdapter as any)._createChangeRequestInterceptor = jest.fn<{
                getRequest: <T>(request: T, entity: Entity, index: number) => T;
                done: (requests: any[]) => void;
            }, [DataServiceSaveContext, SaveBundle]>(
                (sc, sb) => {
                    return (DefaultDataService as any)._createChangeRequestInterceptor(sc, sb);
                });

            ds = new OData4DataService();
            ds.initialize();

            httpClient = new ODataHttpClient();
            ds.httpClient = httpClient;

            httpClient.request = (req, success, error) => {
                response = ({
                    headers: {
                        'Content-Type': 'application/xml',
                    },
                    body: metadataXml,
                    requestUri: req.requestUri,
                    statusCode: '200',
                    statusText: 'OK',
                } as HttpOData.Response);
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            metadataStore = new MetadataStore();
            dataService = new DataService({
                serviceName: 'http://localhost',
                hasServerMetadata: true,
            });

            await ds.fetchMetadata(metadataStore, dataService);
        });

        beforeEach(() => {
            entityManager = new EntityManager({
                metadataStore
            });

            saveContext = ({
                adapter: ds,
                dataService,
                resourceName: '',
                routePrefix: '',
                entityManager,
                contentKeys: [],
                tempKeys: []
            } as any as DataServiceSaveContext);

            saveBundle = ({
                entities: [],
                saveOptions: SaveOptions.defaultInstance
            } as SaveBundle);

            batchResponse = createBatchResponse();

            response = ({
                headers: {
                    'Content-Type': 'application/json',
                },
                data: batchResponse,
                requestUri: '',
                statusCode: '200',
                statusText: 'OK',
            } as HttpOData.Response);
        });

        it('should throw error for OData Error', async () => {
            httpClient.request = (req, success, error) => {
                error({} as HttpOData.Error);
                return {} as HttpOData.RequestWithAbort;
            };

            await expect(
                ds.saveChanges(saveContext, saveBundle)
            ).rejects.toThrowError(expect.any(ODataError));
        });

        it('should send request as POST', async () => {
            let result: string;
            httpClient.request = (req, success, error) => {
                result = req.method;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.saveChanges(saveContext, saveBundle);

            const expected = 'POST';
            expect(result).toBe(expected);
        });

        it('should send request to $batch', async () => {
            let result: string;
            httpClient.request = (req, success, error) => {
                result = req.requestUri;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.saveChanges(saveContext, saveBundle);

            expect(result).toBe(`${saveContext.routePrefix}$batch`);
        });

        it('should include headers in request', async () => {
            let result: { [name: string]: string };
            httpClient.request = (req, success, error) => {
                result = req.headers;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await ds.saveChanges(saveContext, saveBundle);

            // tslint:disable-next-line:forin
            for (const header in ds.headers) {
                expect(result[header]).toBe(ds.headers[header]);
            }
        });

        it('should not send unchanged entity', async () => {
            let batchRequest: Batch.BatchRequest;
            httpClient.request = (req, success, error) => {
                batchRequest = req.data;
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            const entity = entityManager.createEntity('Revision', { Id: '1' });
            entity.entityAspect.setUnchanged();
            saveBundle.entities.push(entity);

            await ds.saveChanges(saveContext, saveBundle);

            entity.entityAspect.setDetached(); // this is needed or else it causes issues in other tests
            saveBundle.entities = []; // this is needed or else the id count will get off

            const result = batchRequest.__batchRequests[0].__changeRequests[0];
            expect(result).toBeUndefined();
        });

        it('should throw error for failed batch response', async () => {
            batchResponse.__batchResponses[0].__changeResponses[0] =
                ({
                    response: {
                        statusCode: '500',
                        statusText: 'Test error'
                    }
                } as Batch.FailedResponse);

            httpClient.request = (req, success, error) => {
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await expect(ds.saveChanges(saveContext, saveBundle))
                .rejects.toThrowError(expect.any(ODataError));
        });

        it('should throw error for batch response with no status code', async () => {
            (batchResponse.__batchResponses[0].__changeResponses[0] as Batch.ChangeResponse).statusCode = '';

            httpClient.request = (req, success, error) => {
                success(response);
                return {} as HttpOData.RequestWithAbort;
            };

            await expect(ds.saveChanges(saveContext, saveBundle))
                .rejects.toThrowError(expect.any(ODataError));
        });

        describe('with new entity', () => {
            let entity: Entity;
            let batchRequest: Batch.BatchRequest;
            let batchChangeRequest: Batch.ChangeRequest;
            let saveResult: SaveResult;

            beforeAll(async () => {
                batchResponse = createBatchResponse(1, {
                    Id: '2',
                    QuotedWithValue: '123',
                    QuotedWithoutValue: null
                });

                response.data = batchResponse;

                entity = entityManager.createEntity('Revision', { Id: '1' });
                entity.entityType.autoGeneratedKeyType = AutoGeneratedKeyType.Identity;
                entity.entityType.dataProperties.push(new DataProperty({
                    isUnmapped: true,
                    name: 'Unmapped',
                    nameOnServer: 'Unmapped',
                    dataType: DataType.String
                }));
                entity.entityType.dataProperties.push(new DataProperty({
                    isUnmapped: false,
                    name: 'QuotedWithValue',
                    nameOnServer: 'QuotedWithValue',
                    dataType: DataType.Decimal
                }));
                entity.entityType.dataProperties.push(new DataProperty({
                    isUnmapped: false,
                    name: 'QuotedWithoutValue',
                    nameOnServer: 'QuotedWithoutValue',
                    dataType: DataType.Decimal
                }));

                entity['Unmapped'] = 'This should not get pushed to the server';
                entity['QuotedWithValue'] = 123;
                entity['QuotedWithoutValue'] = null;

                saveBundle.entities.push(entity);

                httpClient.request = (req, success, error) => {
                    batchRequest = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                saveResult = await ds.saveChanges(saveContext, saveBundle);

                batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[0];
            });

            it('should send batch request Content-ID header', () => {
                expect(batchChangeRequest.headers['Content-ID']).toBe('1');
            });

            it('should set correct requestUri', () => {
                const expected = `${dataService.serviceName}${entity.entityType.defaultResourceName}`;
                expect(batchChangeRequest.requestUri).toBe(expected);
            });

            it('should set method to POST', () => {
                const expected = 'POST';
                expect(batchChangeRequest.method).toBe(expected);
            });

            it('should send property value', () => {
                expect(batchChangeRequest.data['Id']).toBe(entity['Id']);
            });

            it('should not send Unmapped property value', () => {
                expect(batchChangeRequest.data['Unmapped']).toBeUndefined();
            });

            it('should not send Unmapped property value', () => {
                expect(batchChangeRequest.data['Unmapped']).toBeUndefined();
            });

            it('should toString quoted value', () => {
                expect(batchChangeRequest.data['QuotedWithValue']).toBe('123');
            });

            it('should pass null quoted value', () => {
                expect(batchChangeRequest.data['QuotedWithoutValue']).toBeNull();
            });

            it('should set key mapping for identity key', () => {
                expect(saveResult.keyMappings[0]).toEqual({
                    entityTypeName: 'Revision:#OData4Test.Models',
                    tempValue: '1',
                    realValue: '2'
                });
            });
        });

        describe('with updated entity', () => {
            let entity: Entity;
            let batchRequest: Batch.BatchRequest;
            let batchChangeRequest: Batch.ChangeRequest;

            beforeAll(async () => {
                batchResponse = createBatchResponse(1);
                response.data = batchResponse;

                entity = entityManager.createEntity('Revision', { Id: '1', Content: 'New content' });
                entity.entityAspect.originalValues['Content'] = 'Old content';
                entity.entityAspect.setModified();
                saveBundle.entities.push(entity);

                httpClient.request = (req, success, error) => {
                    batchRequest = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.saveChanges(saveContext, saveBundle);

                batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[0];
            });

            it('should send batch request Content-ID header', () => {
                expect(batchChangeRequest.headers['Content-ID']).toBe('1');
            });

            it('should send batch request Content-Type header', () => {
                expect(batchChangeRequest.headers['Content-Type']).toBe('application/json;IEEE754Compatible=true');
            });

            it('should set correct requestUri', () => {
                const expected = `${dataService.serviceName}${entity.entityType.defaultResourceName}('${entity['Id']}')`;
                expect(batchChangeRequest.requestUri).toBe(expected);
            });

            it('should set method to PATCH', () => {
                const expected = 'PATCH';
                expect(batchChangeRequest.method).toBe(expected);
            });

            it('should send changed property value', () => {
                expect(batchChangeRequest.data['Content']).toBe('New content');
            });

            it('should not send unchanged property value', () => {
                expect(batchChangeRequest.data['Id']).toBeUndefined();
            });

            it('should set extraMetadata on the entity aspect', () => {
                const result = entity.entityAspect.extraMetadata;
                const expected = `${entity.entityType.defaultResourceName}('${entity['Id']}')`;
                expect(result['uriKey']).toBe(expected);
            });
        });

        describe('with deleted entity', () => {
            let entity: Entity;
            let batchRequest: Batch.BatchRequest;
            let batchChangeRequest: Batch.ChangeRequest;

            beforeAll(async () => {
                batchResponse = createBatchResponse(1);
                response.data = batchResponse;

                entity = entityManager.createEntity('ArticleAuthor', { AuthorId: 1, ArticleId: '2' });
                entity.entityAspect.setUnchanged();
                entity.entityAspect.setDeleted();
                saveBundle.entities.push(entity);

                httpClient.request = (req, success, error) => {
                    batchRequest = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.saveChanges(saveContext, saveBundle);

                batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[0];
            });

            it('should set method to DELETE', () => {
                const expected = 'DELETE';
                expect(batchChangeRequest.method).toBe(expected);
            });

            it('should set correct requestUri', () => {
                const expected = `${dataService.serviceName}${entity.entityType.defaultResourceName}(ArticleId='${entity['ArticleId']}',AuthorId=${entity['AuthorId']})`;
                expect(batchChangeRequest.requestUri).toBe(expected);
            });

            it('should set extraMetadata on the entity aspect', () => {
                const result = entity.entityAspect.extraMetadata;
                const expected = `${entity.entityType.defaultResourceName}(ArticleId='${entity['ArticleId']}',AuthorId=${entity['AuthorId']})`;
                expect(result['uriKey']).toBe(expected);
            });
        });

        describe('with multiple updated entities', () => {
            const entities: Entity[] = [];
            let batchRequest: Batch.BatchRequest;

            beforeAll(async () => {
                batchResponse = createBatchResponse(1);
                response.data = batchResponse;

                const entity1 = entityManager.createEntity('Revision', { Id: '1', Content: 'New content' });
                entity1.entityAspect.originalValues['Content'] = 'Old content';
                entity1.entityAspect.extraMetadata = { etag: '33asfasrwasf' };
                entity1.entityAspect.setModified();
                entities.push(entity1);

                const entity2 = entityManager.createEntity('Article', { Id: '1', Title: 'New Title' });
                entity2.entityAspect.originalValues['Title'] = 'Old Title';
                entity2.entityAspect.extraMetadata = {
                    uriKey: `${dataService.serviceName}${entity2.entityType.defaultResourceName}('${entity2['Id']}')`
                };
                entity2.entityAspect.setModified();
                entities.push(entity2);

                saveBundle.entities = entities;

                httpClient.request = (req, success, error) => {
                    batchRequest = req.data;
                    success(response);
                    return {} as HttpOData.RequestWithAbort;
                };

                await ds.saveChanges(saveContext, saveBundle);
            });

            it('should send batch request Content-ID header', () => {
                entities.forEach((entity, idx) => {
                    const batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[idx];
                    expect(batchChangeRequest.headers['Content-ID']).toBe(idx + 1 + '');
                });
            });

            it('should set correct requestUri', () => {
                entities.forEach((entity, idx) => {
                    const batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[idx];
                    const expected = `${dataService.serviceName}${entity.entityType.defaultResourceName}('${entity['Id']}')`;
                    expect(batchChangeRequest.requestUri).toBe(expected);
                });
            });

            it('should set method to PATCH', () => {
                const expected = 'PATCH';
                entities.forEach((entity, idx) => {
                    const batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[idx];
                    expect(batchChangeRequest.method).toBe(expected);
                });
            });

            it('should send changed property value', () => {
                let batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[0];
                expect(batchChangeRequest.data['Content']).toBe('New content');
                batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[1];
                expect(batchChangeRequest.data['Title']).toBe('New Title');
            });

            it('should not send unchanged property value', () => {
                entities.forEach((entity, idx) => {
                    const batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[idx];
                    expect(batchChangeRequest.data['Id']).toBeUndefined();
                });
            });

            it('should set extraMetadata on the entity aspect', () => {
                entities.forEach((entity, idx) => {
                    const result = entity.entityAspect.extraMetadata;
                    const expected = `${entity.entityType.defaultResourceName}('${entity['Id']}')`;
                    expect(result['uriKey']).toContain(expected);
                });
            });

            it('should set If-Match header to etag value', () => {
                const entity = entities[0];
                const batchChangeRequest = batchRequest.__batchRequests[0].__changeRequests[0];
                const result = batchChangeRequest.headers['If-Match'];
                const expected = entity.entityAspect.extraMetadata['etag'];
                expect(result).toBe(expected);
            });
        });
    });
});

function createBatchResponse(contentId?: number, data?: any) {
    const headers = contentId ? { 'Content-ID': contentId.toString() } : null;

    const result = {
        __batchResponses: [
            {
                __changeResponses: [
                    {
                        headers,
                        statusCode: '200',
                        statusText: 'OK',
                        data
                    }
                ]
            }
        ]
    } as Batch.BatchResponse;
    return result;
}
