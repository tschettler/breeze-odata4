import { AutoGeneratedKeyType, config, core, DataProperty, DataService, DataServiceAdapter, DataType, Entity, EntityAspect, EntityQuery, EntityType, JsonResultsAdapter, MetadataStore, NodeContext, QueryContext, SaveResult } from 'breeze-client';
import { deferred, oData } from 'ts-odatajs';

import { DataTypeSymbolEx, DataServiceEx, ODataServiceAdapter, ODataError, DataServiceSaveContext, EntityAspectExt, EntityManagerEx } from './interfaces';
import { ClassRegistry } from "./ClassRegistry";

import { MetadataAdapter } from "./adapters/metadata-adapter";
import { IdentityAdapter } from "./adapters/identity-adapter";
import { NavigationAdapter } from "./adapters/navigation-adapter";
import { AnnotationAdapter } from "./adapters/annotation-adapter";

import { AnnotationDecorator } from "./decorators/annotation-decorator";
import { StoreGeneratedPatternDecorator } from "./decorators/store-generated-pattern-decorator";
import { DisplayNameDecorator } from "./decorators/display-name-decorator";
import { ValidatorDecorator } from "./decorators/validator-decorator";

export class OData4ServiceAdapter implements ODataServiceAdapter {
    private innerDataServiceAdapter: ODataServiceAdapter = <ODataServiceAdapter>config.getAdapterInstance('dataService', 'WebApi');
    private metadataAdapters: MetadataAdapter[] = [];

    name = 'OData4';

    headers = {
        'OData-Version': '4.0'
    };

    metadata: any;

    initialize(): void {
        core.requireLib("odatajs", "Needed to support remote OData v4 services");
        this.fixODataFormats();

        ClassRegistry.MetadataAdapters.add(IdentityAdapter, NavigationAdapter, AnnotationAdapter);
        ClassRegistry.AnnotationDecorators.add(StoreGeneratedPatternDecorator, DisplayNameDecorator, ValidatorDecorator);

        this.metadataAdapters = ClassRegistry.MetadataAdapters.get();
    }

    _catchNoConnectionError(err: Error) {
        this.innerDataServiceAdapter._catchNoConnectionError(err);
    }

    _createChangeRequestInterceptor(saveContext: DataServiceSaveContext, saveBundle: Object): { getRequest: (request: Object, entity: Entity, index: number) => Object; done: (requests: Object[]) => void } {
        return (<ODataServiceAdapter>this.innerDataServiceAdapter)._createChangeRequestInterceptor(saveContext, saveBundle);
    }

    checkForRecomposition(interfaceInitializedArgs: { interfaceName: string; isDefault: boolean; }): void {
        this.innerDataServiceAdapter.checkForRecomposition(interfaceInitializedArgs);
    }

    fetchMetadata(metadataStore: MetadataStore, dataService: DataService): Promise<any> {
        var deferred = deferred.createDeferred();

        var associations = {};

        var serviceName = dataService.serviceName;
        var url = this.getAbsoluteUrl(dataService, '$metadata');

        // OData.read(url,
        oData.read({
            requestUri: url,
            // headers: { 'Accept': 'application/json'}
            headers: { Accept: 'application/json;odata.metadata=full' }
        },
            (data: any, response: any) => {
                // data.dataServices.schema is an array of schemas. with properties of
                // entityContainer[], association[], entityType[], and namespace.
                if (!data || !data.dataServices) {
                    var error = new Error('Metadata query failed for: ' + url);
                    return deferred.reject(error);
                }
                var csdlMetadata = data.dataServices;
                var schema = csdlMetadata.schema;

                if (schema instanceof Array && schema.length > 1) {
                    for (var prop in schema[1]) {
                        if (prop === 'namespace') {
                            continue;
                        }
                        schema[0][prop] = schema[1][prop];
                    }

                    schema.pop();
                }

                this.metadataAdapters.forEach(a => {
                    oData.utils.forEachSchema(schema, a.adapt)
                });

                // might have been fetched by another query
                if (!metadataStore.hasMetadataFor(serviceName)) {
                    try {
                        metadataStore.importMetadata(csdlMetadata);
                    } catch (e) {
                        deferred.reject(new Error('Metadata query failed for ' + url + '; Unable to process returned metadata: ' + e.message));
                    }

                    metadataStore.addDataService(dataService);
                }

                deferred.resolve(csdlMetadata);

            },
            (error: any) => {
                this.createError(error, url).then((err: Error) => {
                    err.message = 'Metadata query failed for: ' + url + '; ' + (err.message || '');
                    deferred.reject(err);
                });
            },
            oData.metadataHandler
        );

        return deferred.promise();
    }

    executeQuery(mappingContext: { getUrl: () => string; query: EntityQuery; dataService: DataService; }): Promise<any> {
        var deferred = deferred.createDeferred();
        var url = this.getAbsoluteUrl(mappingContext.dataService, mappingContext.getUrl());

        /**
         *  The syntax for getting the count of a collection has changed with v4
         *  http://docs.oasis-open.org/odata/odata/v4.0/errata01/os/complete/part2-url-conventions/odata-v4.0-errata01-os-part2-url-conventions-complete.html#_Toc395267183
         */
        url = url.replace('$inlinecount=allpages', '$count=true');
        url = url.replace('$inlinecount=none', '$count=false');
        url = url.replace(/substringof\(('[^']*')(,|%2C)\s*([^)]*\)?)\)/gi, 'contains($3$2$1)');

        oData.read(
            {
                requestUri: url,
                headers: this.headers
            },
            (data: any, response: any) => {
                var inlineCount;
                if (data['@odata.count']) {
                    // OData can return data['@odata.count'] as a string
                    inlineCount = parseInt(data['@odata.count'], 10);
                }

                deferred.resolve({ results: data.value, inlineCount: inlineCount, httpResponse: response });
            },
            (error: Object) => {
                this.createError(error, url)
                    .then((err: Error) => deferred.reject(err));
            }
        );

        return deferred.promise();
    }

    saveChanges(saveContext: DataServiceSaveContext, saveBundle: Object): Promise<SaveResult> {
        var adapter = saveContext.adapter = this;
        var deferred = deferred.createDeferred();

        saveContext.routePrefix = adapter.getAbsoluteUrl(saveContext.dataService, '');
        var url = saveContext.routePrefix + '$batch';

        var requestData = this.createChangeRequests(saveContext, saveBundle);
        var tempKeys = saveContext.tempKeys;
        var contentKeys = saveContext.contentKeys;

        oData.request({
            //oData.read({
            requestUri: url,
            method: 'POST',
            data: requestData
        },
            (data: any, response: any) => {
                var entities = [];
                var keyMappings = [];
                var saveResult = { entities: entities, keyMappings: keyMappings };
                data.__batchResponses.forEach(br => {
                    br.__changeResponses.forEach((cr, index) => {
                        var response = cr.response || cr;
                        var statusCode = response.statusCode;
                        if ((!statusCode) || statusCode >= 400) {
                            this.createError(cr, url)
                                .then((error: Error) => deferred.reject(error));
                            return;
                        }

                        /**
                         * It seems that the `Content-ID` header is not being properly parsed out by the odatajs library. As a work around
                         * we can assume that each change response is numbered sequentially from 1, and infer the ID from the index in the
                         * br.__changeResponses array.
                         */
                        //var contentId = cr.headers['Content-ID'];
                        var contentId = index + 1;

                        var rawEntity = cr.data;
                        if (rawEntity) {
                            var tempKey = tempKeys[contentId];
                            if (tempKey) {
                                var entityType = tempKey.entityType;
                                if (entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
                                    var tempValue = tempKey.values[0];
                                    // TODO: cleanup after typings get updated
                                    var realKey = entityType.getEntityKeyFromRawEntity(rawEntity, DataProperty["getRawValueFromServer"]); // TODO: Typing is missing function
                                    var keyMapping = { entityTypeName: entityType.name, tempValue: tempValue, realValue: realKey.values[0] };
                                    keyMappings.push(keyMapping);
                                }
                            }
                            entities.push(rawEntity);
                        } else {
                            var origEntity = contentKeys[contentId];
                            entities.push(origEntity);
                        }
                    });
                });

                if (deferred._rejected) {
                    throw deferred.promise.source.exception;
                }

                return deferred.resolve(saveResult);
            }, err => {
                this.createError(err, url)
                    .then((error: Error) => deferred.reject(error));
            }, oData.batch.batchHandler, undefined, this.metadata);

        return deferred.promise();
    }

    getAbsoluteUrl(dataService: DataService, url: string): string {
        return this.innerDataServiceAdapter.getAbsoluteUrl(dataService, url);
        /*var serviceName = (<DataServiceEx>dataService).qualifyUrl('');
        // only prefix with serviceName if not already on the url
        var base = core.stringStartsWith(url, serviceName) ? '' : serviceName;
        // If no protocol, turn base into an absolute URI
        if (window && serviceName.startsWith('//')) {
            // no protocol; make it absolute
            let loc = window.location;
            base = `${loc.protocol}//${loc.host}${core.stringStartsWith(serviceName, '/') ? '' : '/'}{base}`;
        }

        return base + url;*/
    }

    JsonResultsAdapter: JsonResultsAdapter = new JsonResultsAdapter(
        {
            name: 'Test',
            visitNode: (node: {}, mappingContext: QueryContext, nodeContext: NodeContext): { entityType?: EntityType; nodeId?: any; nodeRefId?: any; ignore?: boolean; } => {
                var workingNode = <any>node;
                var result: { entityType?: EntityType; nodeId?: any; nodeRefId?: any; ignore?: boolean; } = {};
                if (node === null) return result;

                var entityTypeName;
                if (nodeContext.nodeType === 'root') {
                    if (mappingContext.query) {
                        entityTypeName = mappingContext.entityManager.metadataStore.getEntityTypeNameForResourceName((<EntityQuery>mappingContext.query).resourceName);
                    } else {
                        // convert from #Namespace.EntityType to EntityType:#Namespace
                        var nodeODataType = node['@odata.type'];
                        var typeParts = nodeODataType.split('.');
                        var typename = typeParts.pop();
                        typeParts[0] = typename + ':' + typeParts[0];
                        entityTypeName = typeParts.join('.');
                    }
                } else if (nodeContext.nodeType === 'navProp' || /* old */ nodeContext.nodeType === 'navPropItem') {
                    entityTypeName = (<any>nodeContext).navigationProperty.entityTypeName;
                }

                var et = entityTypeName && mappingContext.entityManager.metadataStore.getEntityType(entityTypeName, true);
                // OData response doesn't distinguish a projection from a whole entity.
                // We'll assume that whole-entity data would have at least as many properties  (<=)
                // as the EntityType has mapped properties on the basis that
                // most projections remove properties rather than add them.
                // If not, assume it's a projection and do NOT treat as an entity
                if (et /*&& et._mappedPropertiesCount <= Object.keys(node).length - 1*/) {
                    // if (et && et._mappedPropertiesCount === Object.keys(node).length - 1) { // OLD
                    result.entityType = <EntityType>et;
                    /*var uriKey = metadata.uri || metadata.id;
                        if (uriKey) {
                            // Strip baseUri to make uriKey a relative uri
                            // Todo: why is this necessary when absolute works for every OData source tested?
                            var re = new RegExp('^' + mappingContext.dataService.serviceName, 'i')
                            uriKey = uriKey.replace(re, '');
                        }*/
                    (<any>result).extraMetadata = {
                        //uriKey: uriKey,
                        //etag: etag

                    };

                }

                // OData v3 - projection arrays will be enclosed in a results array
                if (workingNode.results) {
                    (<any>result).node = workingNode.results;
                }

                var propertyName = nodeContext.propertyName;
                result.ignore = workingNode.__deferred != null || propertyName === '__metadata' ||
                    // EntityKey properties can be produced by EDMX models
                    (propertyName === 'EntityKey' && workingNode.$type && core.stringStartsWith(workingNode.$type, 'System.Data'));
                result.ignore = false;
            }
        }
    );

    registerType<T>(): void {

    }

    private createChangeRequests(saveContext: DataServiceSaveContext, saveBundle: Object) {
        var changeRequestInterceptor = (<ODataServiceAdapter>saveContext.adapter)._createChangeRequestInterceptor(saveContext, saveBundle);
        var changeRequests = [];
        var tempKeys = [];
        var contentKeys = [];
        var entityManager = saveContext.entityManager;
        var helper = (<EntityManagerEx>entityManager).helper;
        var id = 0;
        var routePrefix = saveContext.routePrefix;

        (<{ entities: Entity[] }>saveBundle).entities.forEach((entity: Entity, index: number) => {
            var aspect = entity.entityAspect;
            id = id + 1; // we are deliberately skipping id=0 because Content-ID = 0 seems to be ignored.
            var request = <{ [key: string]: any; }>{ headers: { 'Content-ID': id, 'Content-Type': 'application/json;IEEE754Compatible=true' } };
            contentKeys[id] = entity;
            if (aspect.entityState.isAdded()) {
                var resourceName = saveContext.resourceName || entity.entityType.defaultResourceName;
                request.requestUri = routePrefix + entity.entityType.defaultResourceName;
                request.method = 'POST';
                request.data = helper.unwrapInstance(entity, this.transformValue);
                tempKeys[id] = aspect.getKey();
            } else if (aspect.entityState.isModified()) {
                this.updateDeleteMergeRequest(request, aspect, routePrefix);
                request.method = 'PATCH';
                request.data = helper.unwrapChangedValues(entity, entityManager.metadataStore, this.transformValue);
                // should be a PATCH/MERGE
            } else if (aspect.entityState.isDeleted()) {
                this.updateDeleteMergeRequest(request, aspect, routePrefix);
                request.method = 'DELETE';
            } else {
                return;
            }
            request = changeRequestInterceptor.getRequest(request, entity, index);
            changeRequests.push(request);
        });
        saveContext.contentKeys = contentKeys;
        saveContext.tempKeys = tempKeys;
        changeRequestInterceptor.done(changeRequests);
        return {
            __batchRequests: [
                {
                    __changeRequests: changeRequests
                }
            ]
        };

    }

    private transformValue(prop: DataProperty, val: any) {
        if (prop.isUnmapped) return undefined;
        if (prop.dataType === DataType.DateTimeOffset) {
            // The datajs lib tries to treat client dateTimes that are defined as DateTimeOffset on the server differently
            // from other dateTimes. This fix compensates before the save.
            val = val && new Date(val.getTime() - (val.getTimezoneOffset() * 60000));
            // TODO: cleanup after typings get updated
        } else if ((<DataTypeSymbolEx>prop.dataType).quoteJsonOData) {
            val = val != null ? val.toString() : val;
        }
        return val;
    }

    private updateDeleteMergeRequest(request, aspect: EntityAspect, routePrefix) {
        var uriKey;
        var extraMetadata = aspect.extraMetadata;
        if (extraMetadata == null) {
            uriKey = this.getUriKey(aspect);
            aspect.extraMetadata = {
                uriKey: uriKey
            }
        } else {
            uriKey = extraMetadata["uriKey"] || this.getUriKey(aspect);
            if (extraMetadata["etag"]) {
                request.headers['If-Match'] = extraMetadata["etag"];
            }
        }
        request.requestUri =
            // use routePrefix if uriKey lacks protocol (i.e., relative uri)
            uriKey.indexOf('//') > 0 ? uriKey : routePrefix + uriKey;
    }

    private getUriKey(aspect: EntityAspect): string {
        var entityType = aspect.entity.entityType;
        var resourceName = entityType.defaultResourceName;
        var kps = entityType.keyProperties;
        var uriKey = resourceName + '(';
        if (kps.length === 1) {
            uriKey = uriKey + this.fmtProperty(kps[0], aspect) + ')';
        } else {
            var delim = '';
            kps.forEach(kp => {
                uriKey = uriKey + delim + kp.nameOnServer + '=' + this.fmtProperty(kp, aspect);
                delim = ',';
            });
            uriKey = uriKey + ')';
        }
        return uriKey;
    }

    private fmtProperty(prop: DataProperty, aspect: EntityAspect) {
        // TODO: cleanup after typings get updated
        return (<DataTypeSymbolEx>prop.dataType).fmtOData((<EntityAspectExt>aspect).getPropertyValue(prop.name));
    }

    private async createError(error, url) {
        // OData errors can have the message buried very deeply - and nonobviously
        // this code is tricky so be careful changing the response.body parsing.
        var result = new ODataError();
        var response = error && <Response>error.response;
        if (!response) {
            // in case DataJS returns 'No handler for this data'
            result.message = error;
            result.statusText = error;
            return result;
        }

        result.message = response.statusText;
        result.statusText = response.statusText;
        result.status = response.status;
        // non std
        if (url) result.url = url;
        result.body = response.body;
        if (response.body) {
            var nextErr;
            try {
                var body = await response.json();
                result.body = body;
                // OData v3 logic
                if (body['odata.error']) {
                    body = body['odata.error'];
                }
                var msg = '';
                do {
                    nextErr = body.error || body.innererror;
                    if (!nextErr) msg = msg + this.getMessage(body);
                    nextErr = nextErr || body.internalexception;
                    body = nextErr || body;
                } while (nextErr);
                if (msg.length > 0) {
                    result.message = msg;
                }
            } catch (e) {

            }
        }
        this._catchNoConnectionError(result);
        return result;
    }

    private getMessage(body: any): string {
        var msg = body['message'] || body['Message'] || '';
        return ((typeof (msg) === 'string') ? msg : msg.value) + '; ';
    }

    private fixODataFormats() {
        // TODO: cleanup after typings get updated
        (<DataTypeSymbolEx>DataType.Int64).fmtOData = fmtFloat;
        (<DataTypeSymbolEx>DataType.Decimal).fmtOData = fmtFloat;
        (<DataTypeSymbolEx>DataType.Double).fmtOData = fmtFloat;
        (<DataTypeSymbolEx>DataType.DateTime).fmtOData = fmtDateTime;
        (<DataTypeSymbolEx>DataType.DateTimeOffset).fmtOData = fmtDateTimeOffset;
        (<DataTypeSymbolEx>DataType.Time).fmtOData = fmtTime;
        (<DataTypeSymbolEx>DataType.Guid).fmtOData = fmtGuid;

        function fmtFloat(val) {
            if (val == null) return null;
            if (typeof val === "string") {
                val = parseFloat(val);
            }
            return val;
        }

        function fmtDateTime(val) {
            if (val == null) return null;
            try {
                return val.toISOString();
            } catch (e) {
                throwError("'%1' is not a valid dateTime", val);
            }
        }

        function fmtDateTimeOffset(val) {
            if (val == null) return null;
            try {
                return val.toISOString();
            } catch (e) {
                throwError("'%1' is not a valid dateTime", val);
            }
        }

        function fmtTime(val) {
            if (val == null) return null;
            if (!core.isDuration(val)) {
                throwError("'%1' is not a valid ISO 8601 duration", val);
            }
            return val;
        }

        function fmtGuid(val) {
            if (val == null) return null;
            if (!core.isGuid(val)) {
                throwError("'%1' is not a valid guid", val);
            }
            return val;
        }

        function throwError(msg, val) {
            msg = core.formatString(msg, val);
            throw new Error(msg);
        }
    }
}